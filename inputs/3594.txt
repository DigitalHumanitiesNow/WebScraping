In this second part, we will explore some of the more advanced features of the BookReader, namely full-text search, highlighting and the display of a table of contents. All of these features require some server-side code, which I will not go into in this article, as the implementation heavily depends on your environment. I will, however, detail the data that the BookReader requires, so you should have little trouble implementing it yourself.  Table of contents On the client side, you have to call the updateTOC method of the BookReader object with a TOC array. This has to be done after you have initialized the reader with the init method. You can either hardcode it, or obtain it dynamically via an AJAX call. For an AJAX call, your code might look something like this: // Get and set TOC jQuery.ajax({   async: false,   url: "/api/get_toc?name=my_bookname",   dataType: "json",   success: function(data) {     br.updateTOC(data['toc']);   } });  The TOC array has to be in this very straightforward format: [{    'title': 'chapter title',    'pagenum': '0004'  },  // More TOC items.... ]  Please note that the BookReader does not support nested entries at the moment, your structure has to be flat.   Full-Text search and highlighting On the client-side, the search functionality has to be implemented in the search method of the BookReader object. In it, you have to provide the API endpoint that the reader can use for its search queries. It should look something like this: br.search = function(term) {   $('#textSrch').blur(); //cause mobile safari to hide the keyboard    // You will have to change this for your own environment   var url = "/api/search?query="+ term;   this.searchTerm = term;    // Clear old search results   this.removeSearchResults();    // Display a progress dialog   this.showProgressPopup('<img id="searchmarker" src="'+this.imagesBaseURL + 'marker_srch-on.png'+'"> Search results will appear below...');    // Do the API call   $.ajax({url:url, dataType:'jsonp', jsonpCallback:'br.BRSearchCallback'}); }  The results of the search query will be parsed to the function that was defined in the jsonpCallBack parameter of the ajax query, in this case BRSearchCallback (you shouldn’t have to change this). The data that the server is supposed to send should look like this: // Name of the client-side callback function br.BRSearchCallback( {     "ia": "bookname", // The name of the book     "q": "term",      // The search query     "matches": [      // Array that contains all of the matches {     "text": "small snippet with higlighted {{{ terms }}} enclosed by triple braces",     "par": [         {             "page": 11  // Page number of the match             "boxes": [  // All highlighted boxes for the page                 {                     // All coordinates are for the image at full resolution                     // and don't have to be changed, even if the image is                     // served scaled.                     "r": 865,   // Offset from the right border                     "l": 735,   // Offset from the left border                     "b": 1570,  // Offset from the bottom border                     "t": 1539,  // Offset from the top border                     "page": 11, // Once again, the page number of the match                 }             ],         }     ] }, // More matches follow here ]})  You can find a reference implementation using Python/Flask and hOCR files on my GitHub: https://github.com/jbaiter/hocrviewer 

Over the years, Iâve managed to learn a number of different programming languages.  Iâm not an expert in all of the languages to which Iâve been exposed, but Iâve written at least one nontrivial program (and in most cases, several such programs) in C, C++, Perl, Python, Java, php, Common Lisp, Scheme, Prolog, and Ruby.  Broaden the definition slightly, and I suppose you could also include Bash, Awk, and sql.  There are a lot of factors involved when making a decision about which language to use for a particular project, and very few of them have to do with a language being the âbest languageâ as such.  C is an excellent language for writing mouse drivers; itâs probably not the best choice for ai.  Java is a miserable language for writing operating systems; itâs quite a good choice for server-side web applications. But of course, even that is a largely subjective matter.  Plenty of people do low-level systems programming (of sorts) in Java, write gui applications in C, and do ai with php (okay, maybe not). And anyway, this isnât even the biggest factor.  You pick a language because your âgroupâ (your company, your project, your school) uses that language, because itâs the one you know best (or the only one you know), because thereâs a fantastic library available for that language that fits perfectly with what you want to do, and so forth.  The question of which language is best is also full of minor religious questions.  Static typing or dynamic typing?  Interpreted or compiled?  Object oriented?  Functional?  Procedural?  Garbage collected?  Since it is provably possible to write anything computationally tractable in any language, one finds oneself reduced to a balanced tri-fold truism about programming languages:  All languages (approaches to compilation, syntax, etc.) have advantages and disadvantages   The âbest languageâ is likely to be the one that is most suited to the particular task at hand   Javascript is the worst language ever But really, thatâs no fun at all.  It may be true that questions about which language is best are mostly subjective, but if you write software for a living, your own likes and dislikes begin to seem like truisms themselves.  Surely the cabinetmaker doesnât need to justify her love of a particular hand plane?  Of all the languages on my list, there are three that I genuinely love: C, Ruby, and Lisp.  And the greatest of these is Lisp.  In fact, Iâll just say it: Lisp is the Greatest Language Ever.  Period.  The reasons why Lisp is the Ultimate Language have been eloquently expressed elsewhere, so I wonât rehearse the technical merits of the language (particularly since, as I just noted, such rehearsals are futile).  I will say, though, that it radically changed the way I think about programming (in any language).  My experience with Lisp was something akin to my fatherâs experience with Wagner several years ago.  He had been listening to opera for many years, owned a vast collection, and had become quite an âexpert listener,â but hadnât purchased any Wagner.  So he bought a copy of Das Rheingold.  He tried to like it, but the first few listens left him cold.  In fact, he really thought it was awful (despite the fact that many of his fellow opera afficianados consider it possibly The Greatest Opera Ever written).  After awhile, though, he found that several passages were beginning to grow on him.  In fact, he started to really like Das Rheingold.  So, he bought the second one (*Die WalkÃ¼re).  *Same thing.  Sounded like noise.  By the time he finished, he told me that he had to put away *Der Ring des Nibelungen *because, as he put it, âIt was making the rest of my opera collection look amateurish.  Itâs truly the greatest opera ever.â  My experience learning Lisp and coding a few serious programs in it was deeply profound.  Afterward, most of the other languages I had been using regularly seemed silly and inane.  I found myself saying things like, âIâve spent an hour on this method, and I know I could knock it off in three lines of perfectly elegant Lisp!â  And what I was lacking in those languages was a whole host of programming constructs I had either never heard of or only dimly understood before learning Lisp.  Passing a function into a function?  Why would you ever want to do that!  You wouldnât.  Unless you got seriously into Lisp, in which case you find yourself (a) doing it all the time and (b) writing much more elegant, expressive code as a result.  Same goes for closures, continuations, anonymous functions, and macros.  Macros, in particular, might be the most dazzling thing Iâve ever seen in programming.  Programming is all about âextending the language.â Any language will have hundreds of built-in functions, and when you write an application, you are essentially using those functions to write new ones for your own application.  But there are major limits to this.  You might be able to write a function called âread_data_stream()â or âsort_pyramid(),â but you canât extend the language at more fundamental levels.  You canât, for example, write your own if-then-else block or for-loop (and have it work like a part of the language itself). In Lisp, you can â and you find yourself doing it effortlessly after awhile.  In fact, you find yourself using Lisp to write the programming language you wish existed for your particular problem.  And with Lisp, that is a thousand times easier than it sounds.  Do that for a few weeks, and all the other languages will seem like crude stone tools.  Iâve spent the last week or so writing in Ruby.  Itâs a wonderful language.  Itâs a joy to program in it, and Iâm almost always trying to find ways to overcome the various reasons not to (âthatâs not the language of the project,â âthere arenât enough libraries,â etc.).  I know it like the back of my hand, and I teach the language every year.  It even has a number of Lispy constructs (like closures, continuations, and anonymous functions).  But it ainât no Lisp.  In fact, the only way it could be as good as Lisp would be for it to be a Lisp dialect (which it is not).  But last week, I was writing proof-of-concept code.  There was no one telling me what language to use, no âaudienceâ for the code, and there were good, serviceable libraries available for Common Lisp, Ruby, Java, Python and Perl.  I went with Ruby.  The question, of course, is why not write it in The Greatest Language Ever?  Well, thatâs a separate rant, which Iâll save for another post.

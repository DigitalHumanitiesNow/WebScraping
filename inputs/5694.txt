I ended my last post, The Greatest Language Ever, with a personal conundrum.  Why is it that, given a project for which the choice of language was not influenced by extraneous factors, did I choose Ruby rather than Lisp?  Anyone who has lingered around the Lisp community would probably be able to see the answer coming: lack of libraries, no easy way to get a standalone binary, not enough momentum behind the language, the loneliness of being the only hacker in sight using Lisp, lack of integration with posix, etc., etc.  And the Lisp fans have various answers prepared for all of these.  If you go over to comp.lang.lisp and search for the keywords in the last sentence, you can see the whole battle.  In fact, you can peruse at least a decadeâs worth of the same questions and answers going back and forth.  The short answer is usually that Common Lisp does all of these things.  In other words, there are many excellent libraries, you can create standalone programs, Lisp is going to undergo a great resurgence any day now (have you read Peter Seibelâs excellent book?  It won a Jolt Award!), and you can integrate with posix.  But the situation â my situation and the situation of many others â is more complicated than that.  In fact, I think both sides are right.  But rather than pick through the claims and counterclaims, let me step back for a moment and talk about The Greatest Language Possible.  If the Greatest Language Ever is a ridiculous notion (for the reasons outlined in my previous post), the Greatest Language Possible is even more so.  Yet in a way, the idea is even more irresistible.  Frederick Brooks was right to note, in The Mythical Man-Month, that programmers are optimists.  We will vastly underestimate the time it takes to do something, naively declare things to be easy or even âtrivialâ to implement, and generally approach most problems, to our extreme peril, with a can-do attitude.  When we talk about dream languages, weâre really expressing a longing for the perfect tool â the one that really would make everything easy and trivial.  I mentioned that my favorite languages are C, Ruby, and Lisp, and I think my perfect language would blend all three.  A few years ago, I posted the following on Slashdot.  It was essentially a response to a critique of C:     You know, I never hear anyone disagree with the type of thing youâre saying here. Itâs unsafe, thereâs no garbage collection, the pointer abstraction is confusing, the macro system is terrible, itâs just high level assembler, etc., etc.      But there are lots and lots and lots of people who code Linux programs in C â the vast majority of the programs I come across, at any rate. These people surely arenât being coerced into it by some manager. I assume that most of the people writing sophisticated software are multilingual (hard to get to get really good without learning at least half a dozen languages, in my opinion). They surely all know about oo, templates, assertions, abstract classes, and whatever other language features are out there.        Itâs like the biggest silent majority in computing. All these people merrily hacking away in C without complaint.      I would like to hear someone talk about why they like to code in C. Iâm not asking for a language war. I would just like to hear from this silent majority.     The first response back said it all:     C is for people who understand how computers work, and how they work best, and who canât or wonât accept âeasierâ or âfasterâ (to develop in) programming languages just because they wonât always generate the best code.     Now, them are fightinâ words, for sure, but I think I agree.  I am one of those who has been merrily hacking away in C (nothing big, just stuff for my own system) for years without a complaint.  And I think I love it because of its primitive nature.  Thereâs something about programming on the metal â thinking about memory usage, imagining the content of the registers, breaking open every black box â that is appealing in some basic way.  But thereâs also the practical matter of being a unix programmer.  C is the common tongue of unix.  And itâs fast.  Really, really fast.  Ruby is a joy for exactly the opposite reason.  It keeps you blissfully unaware of the details.  There are even times when you feel like youâre speaking English to the computer.  Itâs elegant, âfast enoughâ in most cases, and there are lots and lots of libraries that make it easy to talk to native C interfaces.  In a way, I always want the library to be in C, but at the same time, I always want to call the library in Ruby.  Itâs even pretty Lispy, as non-Lisp languages go, and includes some direct borrowings (though, as an aside, I find it interesting that I rarely use lambda functions when writing Ruby, and I think itâs because the Algol-like syntax doesnât lend itself to this kind of expression.  The parentheses in Lisp arenât just there for decoration.)  And then thereâs Lisp.  So elegant and expressive, so much fun to write.  Half the time, I donât know whether to laugh or cry.  Somewhere in here is my ideal.  Not my metaphysical pronouncement on languages, but the tool I wish I had at my disposal.  Itâs as fast as C, yet as high as Ruby.  It speaks unix effortlessly, and itâs trivial (thereâs that word again!) to call native libraries from it.  It has a vast library (perhaps as a function of it being so tightly integrated with C), and itâs reasonably portable.  Oh, and itâs also a Lisp.  I chose Ruby over the Greatest Language Ever for the recent project not because of any show-stopping defect in the Lisp implementations or overwhelming virtue in Ruby, but because you have to weigh a complex set of factors for the particular problem and hope for the best.  Lisp has the language, but Ruby has the libraries.  It would be possible to hook Lisp into the libraries, but thatâs a complicated matter, and it would constitute a clear case of overengineering just to get some proof-of-concept code working.  Writing those libraries would be the patriotic thing to do, but Lispâs ffis are complicated and I donât have time to do it.  None of this is the fault of Lisp, Lispâs implementors, Lispâs advocates, Lispâs community, or anything else.  Itâs just a hacker on a deadline.  But did I mention that I think Iâve found an implementation of Lisp that does all the things Iâve been talking about?  Could it be the dream language?  Be still my beating heart.  Next post.

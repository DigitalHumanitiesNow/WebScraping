Non-programmers are often bemused to hear programmers speak of beauty and elegance in code.  Itâs a strangely ineffable assignation, yet one that every serious programmer can make.  Some pieces of code are not just utile, but dulci.  And nothing thrills the heart of an engineer like the moment of beauty.  Paul Graham offers a code example in his book On Lisp (out of print but available on line) that strikes me this way.  Itâs just a tiny little âcounterâ procedure:  (defun make-adder (n)   #â(lambda (x) (+ x n)))   This function takes a number, but instead of returning an incremented value, it returns a closure that will add that number to any subsequent function call.  Hence:  (setq add2 (make-adder 2)   add10 (make-adder 10)) (funcall add2 5) 7 (funcall add10 3) 13   Graham calls this an example of a âutility function,â but I must admit that when I first saw it, my reaction wasnât âWow, what a useful thing!â or âAh, now I understand how lexical closures work!â  My reaction was simply, âGood heavens, thatâs gorgeous.â  But why?  Perhaps itâs some convergence between beauty and cleverness.  Cleverness isnât always a virtue in programming (particularly since such moments often exchange clarity for concision), but sometimes things manage to be both clever and beautiful â clever because theyâre beautiful, and beautiful because theyâre clever.  And âclevernessâ is often (though not always) a component of art.  The Mona Lisa exudes a kind ineffable cleverness, as does the astonishing photorealism of Old Masters paintings, and in both cases, itâs not merely craft that produces this sensation.  Beauty in code is not a function of utility at all (though the two often accompany one another).  This code sample (found both in Sitaramâs Teach Yourself Scheme in Fixnum Days and Dybvigâs The Scheme Programming Language) also strikes me as beautiful.  Itâs a set of recursive co-routines for deciding whether a number is even or odd:  (define is-even?   (lambda (n)     (if (= n 0) #t       (is-odd? (- n 1)))))  (define is-odd?   (lambda (n)     (if (= n 0) #f       (is-even? (- n 1)))))   These co-routines pass the number back and forth; you get your answer, because the function that returns the answer will be the last procedure called â the last player with the football, as it were.  In one sense, the code is perfectly practical, since itâs prefatory to a discussion of letrec â a variety of conditional that allows you to assign local variables recursively.  But in another sense, itâs entirely silly.  Scheme, after all, provides both odd? procedures.  But ah, what a beautiful piece of code.  Itâs not, âWow, isnât Lisp great!â or âAh, now I understand letrec!â  Itâs just âWhat a beautiful piece of code.â  For me, at least.  Hand a geek a pocket watch, and he or she will immediately open up the back and stare at the mechanism for an hour.  And if you could persuade that person to speak out loud, theyâd be saying things like, âLook at that!  And that!  Wow, thatâs justâ¦beautiful!â  And that really is something like an aesthetic experience that is in a way indistinguishable from the experience of art.  I donât mean to argue that Lisp is inherently beautiful; the examples are in Lisp because thatâs my current obsession, and Iâm reading a lot of Lisp code these days.  In fact, I think what Iâm talking about here transcends language.  Itâs certainly not a matter of syntax.  One could easily imagine beautiful C, Java, or Fortran.  I had certainly seen lots of examples of beautiful code before I knew anything at all about Lisp.  Got some beautiful code (in any language)?  Iâd love to hear about it.

What can I say?  The Greatest Language Ever and the Greatest Language Possible are both doomed propositions.  The former ignores the infinite variation of use cases, platforms, coding styles, and the sociology of individuals and groups.  The latter does all of that and goes still further by arbitrarily choosing language features for which the âbestâ is likely to be a highly debatable matter.  Like all good philosophical questions, these oneâs donât have concrete answers.  We pose them not to arrive somewhere, but to stimulate thought and further innovation.  But Lisp is still the Greatest Language Ever.  I only learned Lisp a couple of years ago.  Iâm not sure how I got there, really.  I think I might have stumbled on one of Paul Grahamâs essays (perhaps from a Slashdot interview Kent Pitman gave some time ago).  I was thoroughly intrigued by what Graham had to say, and decided to give it a shot.  That, of course, led me into the Scheme vs. Common Lisp debate, as well as to the question of which implementation to use.  I think it took me about an hour to decide against Scheme.  Nearly everything I read about it suggested that it was a highly minimalistic version of Lisp intended for introductory computer science courses and ponderous experiments in the study of languages and algorithms.  In other words, it wasnât meant for serious application development at all.  In fact, the very first Q from the Scheme faq sealed it:     Scheme is often used in computer science curricula and programming language research, due to its ability to represent many programming abstractions with its simple primitives. Common Lisp is often used for real world programming because of its large library of utility functions, a standard object-oriented programming facility (clos), and a sophisticated condition handling system.   So (I concluded), if you want to build real apps you want Common Lisp.  I ended up going with sbcl (which is a fantastic implementation).  I also read Peter Seibelâs book, which is really sensational.  I started this recent series of blog posts, because I wanted to talk about why Iâm both dazzled and frustrated by certain aspects of Common Lisp.  None of my objections involved the language itself (Iâm not even sure I follow some of the critiques of cl that show up on the newsgroups).  My problems were the garden variety ones.  cl folks use Emacs/Slime.  I use Vim (which has very weak support for ide-style development with Lisp).  And anyway, I hate ides.  I want the compiler to compile (or the interpreter to interpret), the debugger to debug, the editor to edit, and I want to switch tools whenever I want.  I also donât want anything abstracting me away from the details of the tools themselves.  Thatâs just me, but there it is.  I loved having a repl, but I hated having just a repl, and while itâs possible to get sbcl to work with a shebang, it involves a lot of hacking of configuration files.  Package installation was often complex and tedious, and the library I was looking for usually wasnât available (or if it was, it had absolutely no documentation whatsoever).  I fully understood the arguments about why itâs hard to create standalone âbinariesâ for cl, but I wondered why there wasnât something like a Java jar file â some easy way to launch an app with minimal fuss.  As Iâve said before, there is a way to do all of this if youâre patient.  But when you read the posts about these matters, you witness a very peculiar rhetorical trend.  Someone posts asking about, say, how you go about creating an âexecutableâ with CLISP or sbcl.  Someone might respond with a howto, but the person asking is much more likely to get a sermon about how they need to free their mind.  Theyâre told about how the line between development and use is blurred in Lisp, about how âstandalone programsâ are actually a myth, since the operating system ships with the C runtime and is therefore providing you with mountains of scaffolding (no different from Lisp!).  Theyâre told that the repl is a perfectly legitimate âshellâ for ordinary users.  And anyway, the unix shell is a horrific hack from which we should all attempt to extricate ourselves.  In fact, itâs really much better to have Lisp insulated from the fallen world of shells, C libraries, conventional interfaces, etc.  You just need to embrace the Lambda Nature.  Yeah.  Whatever.  I get it!  I really do.  I understand these arguments.  In fact, some of my objections are completely unfair (No documentation?  No libraries?  Well surely you can do something about that!).  Other points are absolutely dead on (like the one about the C runtime).  Itâs just that Iâm trying to get my work done and make my users happy.  They will not be happy if they have to fiddle with the common-lisp-controller, set up aliases for asdf, recompile fasls, and then learn Lisp syntax so they can use my program.  And Iâm going to be unhappy if I have to wade through source code for lack of documentation, struggle with the ffi, and spend an hour setting up my system so I can use a particular package.  It may be â in fact it is â the Best Language Ever.  But itâs not the Best Userspace Tool Ever.  Not by a long mile.  So I started looking around for other Lisp alternatives, and this led me to a long, second look at Scheme.  I discovered that the opening salvo of the faq is absolutely true.  It is a very small language, and is therefore ideal for teaching and language research.  But what the faq was leaving out, I think, is the startling implications of a language that is trivially easy to implement (relatively speaking).  If youâre going to implement cl, you better lock and load.  Itâs going to be a major job.  Scheme?  Well thatâs a different story.  The fact that Scheme is easy to implement has led to dozens and dozens of implementations.  Some of them are âpure,â in the sense that they provide the core language and donât concern themselves with os integration. Thatâs perfect if youâre teaching Lisp.  But what if you want to target the jvm (âfor shame!â say the cl folks)?  Or compile to C?  Or run it on a Palm?  Or use it as a systems programming language?  Or embed it in another program?  Or embed it in another programming language? Or put in on a cell phone?  Or use it as the scripting language for your editor?  And we can go further.  What about a Scheme that is designed to work seamlessly with unix?  Or a Scheme that makes it trivially easy to call native libraries?  Or a Scheme that can be used as a shell?  Or a scheme that acts like an ordinary âscripting language?â  What I discovered, is that there are Scheme implementations for all of that.  Theyâre all Scheme (and therefore all Lisp), but none of them try to be all things to all users (or worse, impose philosophical restrictions on how the language is used).  Imagine my delight when I stumbled across Chicken Scheme (one of several that try to fill in a particular programming niche).  This is a Scheme implementation that compiles to C (using a very clever method), which means that you can very easily create the elusive âexecutableâ with a single command, and it will behave like any other native app.  Its package system is brainlessly easy to use, and it has lots of libraries to do good-old-fashioned every day stuff (talk to databases, munge xml, export to csv, etc.).  In fact, it really feels like Ruby or Perl or Python.  But itâs fast!  And itâs Lisp!  That was enough to make me fall in love, but my real moment of epiphany came when I discovered Easyffi.  All of the cl implementations allow you call native functions through a foreign function interface.  I read over some of the specifications for doing that (cffi and uffi).  âYeah, itâs doable,â I thought, âBut itâs going to require some serious effort.â  Hereâs how you call native C libraries from Chicken using Easyffi:  You reference the C header in your source file.   You call the native function (in Scheme). Sorry, did I miss something?  I mean, itâs a little more complicated than that, but not much.  I sat down to write an interface to the native GraphViz library.  I had it working in about a half an hour.  The mind reels.  Iâm speechless.  So, I can just create interfaces to any C library I want (making them as Lispy as I care to with macros and whatnot)?  Just by calling them?  And then I can compile the programs that call those interfaces into fast C code that will behave like an ordinary posix program?  And I can do all this in the Greatest Language Ever!?  Iâm a convert.  Iâve known for awhile that Lisp is the red pill.  Now it seems that, for me at least, Chicken Scheme (and Scheme in general) might be the little blue one.

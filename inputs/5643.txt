   âSaying that computer science does digital humanities because computers are digital is like saying that English does computer science, because cs journals are written in English.â â John Unsworth, in conversation   One often hears, though, that digital humanities is in some sort of fraught relationship with computer science.  The main contention is that digital humanists lack humility when they claim to be technologists themselves.  They fail to recognize that computer science is an entire field â a complex and multifaceted discipline that requires at least some degree of immersion both in its intellectual content and in its communities of practice.  Anyone on the far side of a humanities PhD has no hope of catching up, and is therefore doomed to partial (if not complete) misunderstanding of how to build software systems.  One hears, too, a corollary to these dispiriting observations: namely, that since all of this is true, it is absurd and counterproductive to suggest that humanists engaged in certain kinds of intellectual pursuits might profit from learning to program, studying inferential statistics, or gaining some basic facility with design.  I think all of this is based on a serious misunderstanding of both computer science and software development.  Availing myself of the hieratic notation of both pursuits, let me put forward a phrase that computer scientists themselves often invoke:  computer science != programming   Very few computer scientists disagree with this formulation, because very few are concerned with building tools of any kind.  The ones who do build things are mainly doing so to demonstrate some theoretical idea or to prove the viability of a (presumably novel) engineering principle.  The concrete tools that sometimes emerge from these efforts (compiler generators, programming languages, theorem provers) are mainly side effects of some more abstruse intellectual activity.  The vast majority are not in it to create software.  In fact, very few have the skills necessary to build large production systems, and would cheerfully admit that that is the case.  Even academics engaged in software engineering and human-computer interaction â at first blush, the most eminently practical of all computer science topics â are typically discussing these matters in a way that is entirely detached from any particular language or framework.  Hal Abelson famously began the first lecture for mitâs famed 6.001 (Introduction to Programming) by writing the phrase âcomputer scienceâ on the board.  He then proceeded to explain the ways in which this is an odd term for the subject.  Computer science, he noted, is not really a science; it is also not particularly concerned with computers.  When Iâve pointed this out to colleagues in English and History, some have been shocked by this revelation: âSo what exactly do they do?â  If youâve ever been mistaken for a poet because you are a professor of English, you know well the difficulty of trying to disabuse someone of this mistaken impression.  Itâs not that itâs hard to say concisely what one does, but rather that several complicated discourses are invoked by that explanation.  To say what one does as an English professor is to say, at least in part, what English Studies is.  Programming, by contrast, is a craft skill â a practical matter of getting digital devices to exhibit particular behaviors.  This is not to imply that itâs a simple thing; anyone who has done it seriously knows that it is a ferociously complex thing.  But then again, so is writing.  Professional literary criticism is one of the things you can do with writing, but it is hardly the only thing.  To say that one needs an English degree in order to write well, or that writers who lack this formal training are forever doomed to be amateurs, is to radically mistake the nature of each.  There is, of course, a strong relationship between writing and the study of âliteratureâ (by which I mean something like âthe sum total of that which has been written prior to your own attemptâ).  And so it is with programming.  One way to gain a deep understanding of the algorithms, data structures, engineering techniques, and languages that together make up the act of programming would be to enter a computer science program, where such things are contemplated far in excess of what is required for using them.  But if one is mostly concerned with building things (as opposed to, say, meditation upon their mathematical nature), computer science is a sufficient, but not a necessary condition.  Like most practicing programmers, I have a quite thorough understanding of tree structures, hash functions, stacks and queues, object-oriented programming, closures and continuations, and the sometimes fatally important difference between call-by-reference and call-by-value.  I have never taken a single computer science course in my entire life.  This is not a boast; itâs an admission to being part of an extremely vast group of practicing programmers who are essentially self-taught.  Silicon Valley is full of them.  The history of literature is likewise full of people who not only didnât have English degrees, but who didnât have a degree of any kind.  That is not an argument for why either degree is useless, but neither is it necessary for those without formal training to forever bemoan their deficiencies.  Most practicing programmers wouldnât dare call themselves âcomputer scientists,â but that is because to do so would be to commit a category error, not because it is the aspiration of all those who write code.  I am, I suppose, famous for saying that everyone should learn to program (a statement which I tried, perhaps unsuccessfully, to qualify).  I might further mention that this does not mean becoming a computer scientist.  Whatever digital humanities is, it is surely not the attempt to find innovative ways to conduct concurrency on multicore hardware or to determine whether P = NP.  That doesnât mean there can be no such thing as innovation in dh.  Even if our basic materials are largely the outcome of loftier meditations, it does not follow that we can only combine those materials in predictable ways.  I would hope that it is not programming that distinguishes us, but rather the new affordances we gain as students of human culture.  Perhaps Iâm further moderating my earlier statements about the need for digital humanists to program, but lately, when a colleague asks me whether they should learn to program, I say that they should do that if necessary.  In practical terms, most people â even those with computer science degrees â learn to program because the problem in front of them requires it.  Encounter enough of those problems, and you will one day be a skilled and experienced developer.  You might even encounter someone who mistakes you for a computer scientist, but that is easily dealt with.    âOh, no.  Iâm a poet.â

If you’re using a continuous integration system like Travis, you might have run into the unpleasant situation where you did a few commits on your local development machine, ran all the tests and pushed it to GitHub, all under the assumption that because the tests passed you were good. Unfortunately you forgot to git add that new module you were working on and that a few other already existing files reference. So now you get a nasty email from Travis that your build failed. After a few minutes of looking through GitHub with a puzzled look on your face, you discover the cause of the failure and you commit and push a shameful Add accidentally omitted module. If only you had caught that error before pushing to GitHub, preventing the embarrassing mistake from being recorded in collective coding history forever… Lucky for you, Git added a pre-push hook with version 1.8.1. So all you would have had to do was write one of these that checked out your latest changes to a temporary directory, ran the tests on that clean checkout and only pushed when they passed. Having found myself once too often in that situation, here’s what I came up with: #!/bin/bash  # Put your test commands here, remember to chain them with '&&' function run_tests {     flake8 ./     py.test -q ./tests }  repo_dir=$(pwd) current_branch=$(git symbolic-ref HEAD | sed -e 's,.*/\(.*\),\1,') commits=`git log @{u}..`   # Check if we actually have commits to push if [ -z "$commits" ]; then     exit 0 fi  temp_dir=$(mktemp -d -u) git clone -q $repo_dir $temp_dir -b $current_branch cd $temp_dir run_tests tests_succeeded=$? cd $repo_dir rm -rf $temp_dir if [ $tests_succeeded -ne 0 ]; then     echo "Tests failed."     exit 1 fi  Put that code into the .git/hooks/pre-push file in your git repository and make it executable (chmod +x). Now git should execute it before every push and cancel the push if something went wrong. Should you encounter a mistake like described above, you can always alter your yet unpushed history to correct it (e.g. via git commit —amend). This, of course, is not exactly the cleanest way to go about the whole thing. Better, obviously, would be to run the tests on the clean checkout on every commit, but if you’re like me and your unit-tests are not worthy of Uncle Bob (or even the ‘unit’ in that name…) and take over 30 seconds to run, you really don’t want to be taken out of your flow for every little commit you do.

Well, itâs time to pick up another programming language.  Iâve been doing this about once a year since the late nineties, and in that time, my motivations for programming glossolalia have changed a few times.  At first, I think I mostly wanted to jump on the latest bandwagon.  I was also highly susceptible to arguments from more experienced hackers about how such-and-such a language was the Greatest Thing Ever.  But after awhile, I found myself wanting to study languages because I find them completely fascinating.  Nowadays, I think itâs just a way to expand my thinking about what languages are and what they can do.  But honestly, after doing this ten or twelve times, I find that Iâm beginning to stray into the outer rim.  Whatâs next?  Haskell?  Erlang?  I had more or less decided that Iâd do one of those over the summer, but a couple of days ago I stumbled on Groovy.  Whatâs Groovy?  A language with an absurd name, for one.  But beyond that, Groovy (according to the home page):  is an agile and dynamic language for the Java Virtual Machine   builds upon the strengths of Java but has additional power features inspired by languages like Python, Ruby and Smalltalk   makes modern programming features available to Java developers with almost-zero learning curve   supports Domain-Specific Languages and other compact syntax so your code becomes easy to read and maintain   makes writing shell and build scripts easy with its powerful processing primitives, oo abilities and an Ant dsl   increases developer productivity by reducing scaffolding code when developing web, gui, database or console applications   simplifies testing by supporting unit testing and mocking out-of-the-box   seamlessly integrates with all existing Java objects and libraries   compiles straight to Java bytecode so you can use it anywhere you can use Java Iâve used a few alternative languages for the jvm, including JRuby, Jython, and Kawa.  I mean, whatâs not to like?  The syntax of Ruby, Python, or (be still my beating heart) Scheme with all the might and magic of the Java class library?  What could be better?  In my experience, the original languages and runtime environments are better.  I donât know what it is.  I always feel like the Javish stuff just donât belong there somehow â like itâs some kind of crude hack.  And before I get hate mail, let me say that these implementations are not crude hacks.  Theyâre very skillfully done.  Thereâs just something about the mixture that doesnât sit well with me.  I havenât started looking closely at Groovy yet, but I can see the general plan.  Theyâve taken some of the best ideas from languages like Ruby, Perl, Python, and Smalltalk, kept the general contours of Javaâs C-ish syntax, and built a scripting language that has all the soul-stirring power and ubiquity of the Java class library in a nice little package.  And, of course, itâs trivially easy to embed Groovy in Java or to integrate them in some other way.  Now, I might find it annoying (that is: slow, or poorly documented, or whatever).  But if it really does have the ease of use and expressive power of a good scripting language, I may start teaching it in my Digital Humanities courses.  Iâve been teaching Ruby to English majors for a number of years now, and I still think itâs a magnificent teaching language.  But if Groovy was similarly good for teaching and allowed an easy migration path for students interested in Java, I just might be sold.  Java is the dominant language in dh, and while a few of my students have been able to pick up Java after learning Ruby, it would be nice to have a language that was semantically closer to Java.  I could imagine a class that goes through Groovy, and then ends by starting off with Java.  But then, Groovy really would have to be groovy.  They will have to change the name, though.  Can I really have a course description that says weâll be learning Groovy?  Iâll report back when Iâve played with it some more.

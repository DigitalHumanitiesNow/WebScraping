   I am a fool.  Oh, yes!  I am confused. Others are clear and bright, But I alone am dim and weak. Others are sharp and clever, But I alone am dull and stupid.â Tao Te Ching      Aporia is the normal state of the programmer.â Hugh Cayless, via Twitter   Years ago, when I started teaching programming to humanities students, I would distribute a brief questionnaire on the first day of class that tried to discern âwhere people wereâ with technology.  I asked, of course, if anyone had any programming experience, though I quickly made it clear that this course didnât require any.  Mostly, I was trying to figure out what skills they had already acquired (raw html?  PhotoShop?).  I was also looking for sandbaggers from the cs department; toward the end, I had a list of acronyms and asked them to identify all the ones they could.  Anyone who got vlsi was out.  I soon stopped giving out the questionnaire, though, in favor of a more informal, show-of-hands quiz.  It goes something like this:  Have any of you ever studied programming?  A few, in high school.  How many of you play a musical instrument at any level of proficiency?  Lots.  Have you ever studied a foreign language?  All.  Well enough to make your way in a country where that language is spoken?  Hands are raised tentatively in a series of mezza mezza gestures.  Do you ever read the manual?  The ones who donât overpower the ones who now wonât admit that they do.  Is anyone here a bike mechanic?  Thereâs always one.  For those of you who are not bike mechanics: When your bike breaks, do you try to fix it yourself or call the shop?  Fix it myself.  Then call the shop.  Do you like to play chess? Or go? Or bridge?  A few.  âDonât worry,â I say.  âAny hard game will do.â  Now, the real purpose of this quiz is to do the opposite of what the original questionnaire did: namely, to get everyone to relax about what is required for success in this course.  And while itâs true that Iâve never seen a ukulele-playing, we-donât-need-no-stinking-manual, chess nut fail the course, the questions really have more to do with a habit of mind than with any skill or innate talent.  People who enjoy studying foreign languages tend to make good programmers, but not for any of the more obvious reasons.  Some people acquire languages more quickly than others, but anyone who succeeds at it has developed the remarkable ability to be more-or-less happy while being stupid.  Theyâre not frustrated when they can only say âHelloâ and âGoodbyeâ in French, and they still wonât be frustrated two years later when they still canât really hold a serious conversation in the language.  Whatâs more, theyâll gleefully and enthusiastically start trying out their broken, high-school-textbook French the minute they land in Paris.  One of these days, theyâll âknow French.â  But theyâll think of themselves as âknowing Frenchâ way before that day comes.  Musicians, too, are often natural hackers, and I think itâs because they know what it means to be inept.  Youâre not Eddie Van Halen when you start out on the guitar.  In fact, your fingers hurt for weeks and you wonder how anyone manages to make music with this damn thing.  But hey!  That sounds sort of like âSmoke on the Water.â  And off they go.  Sucking for years.  But then gradually, they donât.  And way before they definitively donât, they think of themselves as guitarists.  People will often cite hard work and a high degree of motivation as the secret to success in these areas.  And while I certainly wonât disagree with that, I think this Zen-like comfort with knowing a little, with being a beginner, with kinda sucking, is the deciding factor in the end.  Theyâre often persistent, and hard working, and all that, but mostly theyâre okay with a process that makes them always feel a bit dumb.  Such people seldom read manuals, in part, because theyâre not bothered by not having Total Information Awareness before they begin.  Such people imagine that they will botch the job before the bike is eventually fixed, and theyâre okay with that.  Every good chess player has suffered through years of humiliating slaughter at the chess board, and had a good time doing it.  And all of this is a very, very good sign in someone âlearning to programâ â not because knowing French or mastering the Queenâs Gambit means you have the right kind of brain, but because programming requires, above all, a quiet, peaceful attitude toward the feeling that you donât really know what youâre doing.    Many academics I meet arenât fond of this sensation, and so approach the acquisition of knowledge like a pilot who has not yet earned their endorsement for night flying.  Theyâre always looking for moments in which they can declare that they are not specialists in eighteenth-century history or cognitive linguistics (usually, right before offering an opinion).  When pressed, theyâll readily acknowledge that anything to which they can claim expertise is, in fact, a vast sea, the surface of which theyâve only barely penetrated.  But the point is that they have a set of degrees and a long list of books theyâve read from beginning to end.  Acquiring expertise in something else will presumably require a similar slog, and only after completing the requisite training will they dare admit to knowing something about it.  Perhaps this is why I hear so many say, with a certain bitter mockery in their voice, âSo, we have to go become computer scientists?!  Such humility might be socially and professionally appropriate, but it wonât do to have such an attitude in your heart when you sit down to âlearn programming.â  Nearly every programmer I know â and I know some great ones â started out not with a course, or a book, or a teacher, but with a problem that was irritating them.  Something in their computational world didnât seem right.  Maybe it was broken, or maybe just missing.  But being comfortable with not-knowing-what-the-hell-theyâre-doing, they decided that getting a computer to do something new was more-or-less like figuring out how to get the chain back on the bike.  They werenât trying to âbe programmersâ any more than the parent determined to fix the kidâs bike is trying to be a âbicycle mechanic.â  But then, it worked.  Just some little hack.  Just some little fix.  Suddenly, they knew more than they did before, and emboldened by that, they decided to go a little further next time.  Sometimes, it happens early: these are the teenagers who go buy a book on C++ because they have a great idea for a game (and who arenât in the least daunted when they canât see their way from âHello, worldâ to 3d graphics).  Sometimes, it happens late (as it did for me, relatively speaking).  The first time I got a Perl script to sort some lines in a text file, I thought I was a genius.  More importantly, I thought I was a programmer.  I might not have admitted that to others, but I knew it.  Or I had fun believing it was true.  And then one day, it was true.  By some more common definition, most of my students arenât âprogrammersâ at the end of my course.  Thereâs a great deal they donât know, and theyâve still never written a long, serious, mission-critical piece of software.  But when it comes to cultivating the right attitude toward it, many of them are programmers by the end of the first week.  Because more than understanding control structures or sorting algorithms, they now see their computational world as something they can fix and change.  In fact, the minute they have an idea for anything they want to write, I let them write it.  There is no problem set I can possibly come up with that could replace the thing theyâve decided to change themselves.  I would like to end this post by saying that anyone can acquire this habit of mind, but Iâm aware that in order to acquire this habit of mind, you have to already have this habit of mind.  But that might be good news.  Because if that sentence struck you as really interesting, you undoubtedly have the mind of a programmer.
